package {{package}}

import {{package}}.metadata.{{prefix}}DatabaseMetaData
import {{package}}.statement.{{prefix}}PreparedStatement
import {{package}}.statement.{{prefix}}Statement
import java.sql.*
import java.util.*
import java.util.concurrent.Executor

class {{prefix}}Connection(props: Map<String, String>) : Connection {

    val io = {{prefix}}IO(props)
    private var isClosed = false
    private val autoCommit = true

    override fun prepareStatement(sql: String) = {{prefix}}PreparedStatement(sql, this)

    override fun prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int) = {{prefix}}PreparedStatement(sql, this)

    override fun prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = {{prefix}}PreparedStatement(sql, this)

    override fun prepareStatement(sql: String, autoGeneratedKeys: Int) = {{prefix}}PreparedStatement(sql, this)

    override fun prepareStatement(sql: String, columnIndexes: IntArray?) = {{prefix}}PreparedStatement(sql, this)

    override fun prepareStatement(sql: String, columnNames: Array<out String>?) = {{prefix}}PreparedStatement(sql, this)

    override fun rollback() = rollback(null)

    override fun prepareCall(sql: String) = prepareCall(sql, 0, 0, 0)

    override fun prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int) = prepareCall(sql, 0, 0, 0)

    override fun getAutoCommit() = autoCommit

    override fun getWarnings(): SQLWarning? = null

    override fun getCatalog(): String? {
        checkConnection()
        return null
    }

    override fun isValid(timeout: Int) = isClosed

    override fun close() {
        isClosed = true
    }

    override fun isClosed() = isClosed

    override fun isReadOnly() = false

    override fun createStatement() = {{prefix}}Statement(this)

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int) = {{prefix}}Statement(this)

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = {{prefix}}Statement(this)

    override fun getMetaData() = {{prefix}}DatabaseMetaData()

    override fun getTransactionIsolation() = Connection.TRANSACTION_NONE

    private fun checkConnection() {
        if (isClosed()) throw SQLException("Connection with Redis is closed")
    }

    // ==== do nothing =========

    override fun clearWarnings() {
        // do nothing
    }

    override fun commit() {
        // do nothing
    }

    override fun setAutoCommit(autoCommit: Boolean) {
        // do nothing
    }

    override fun setClientInfo(name: String, value: String?) {
        // do nothing
    }

    override fun setClientInfo(properties: Properties?) {
        // do nothing
    }

    override fun setTypeMap(map: MutableMap<String, Class<*>>?) {
        // do nothing
    }

    // ==== unsupported =========

    override fun createNClob(): NClob {
        throw SQLFeatureNotSupportedException("createNClob")
    }

    override fun createBlob(): Blob {
        throw SQLFeatureNotSupportedException("createBlob")
    }

    override fun createArrayOf(typeName: String, elements: Array<out Any>?): java.sql.Array {
        throw SQLFeatureNotSupportedException("createArrayOf")
    }

    override fun createSQLXML(): SQLXML {
        throw SQLFeatureNotSupportedException("createSQLXML")
    }

    override fun createClob(): Clob {
        throw SQLFeatureNotSupportedException("createClob")
    }

    override fun getNetworkTimeout(): Int {
        throw SQLFeatureNotSupportedException("getNetworkTimeout")
    }

    override fun isWrapperFor(iface: Class<*>): Boolean {
        throw SQLFeatureNotSupportedException("isWrapperFor")
    }

    override fun setSchema(schema: String) {
        throw SQLFeatureNotSupportedException("setSchema")
    }

    override fun setSavepoint(): Savepoint {
        throw SQLFeatureNotSupportedException("setSavepoint")
    }

    override fun setSavepoint(name: String): Savepoint {
        throw SQLFeatureNotSupportedException("setSavepoint")
    }

    override fun <T : Any?> unwrap(iface: Class<T>?): T {
        throw SQLFeatureNotSupportedException("unwrap")
    }

    override fun setTransactionIsolation(level: Int) {
        throw SQLFeatureNotSupportedException("setTransactionIsolation")
    }

    override fun getSchema(): String {
        throw SQLFeatureNotSupportedException("getSchema")
    }

    override fun createStruct(typeName: String, attributes: Array<out Any>?): Struct {
        throw SQLFeatureNotSupportedException("createStruct")
    }

    override fun setReadOnly(readOnly: Boolean) {
        throw SQLFeatureNotSupportedException("setReadOnly")
    }

    override fun getHoldability(): Int {
        throw SQLFeatureNotSupportedException("getHoldability")
    }

    override fun getTypeMap(): MutableMap<String, Class<*>> {
        throw SQLFeatureNotSupportedException("getTypeMap")
    }

    override fun getClientInfo(name: String): String {
        throw SQLFeatureNotSupportedException("getClientInfo")
    }

    override fun getClientInfo(): Properties {
        throw SQLFeatureNotSupportedException("getClientInfo")
    }

    override fun nativeSQL(sql: String): String {
        throw SQLFeatureNotSupportedException("nativeSQL")
    }

    override fun prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): CallableStatement {
        throw SQLFeatureNotSupportedException("prepareCall")
    }

    override fun releaseSavepoint(savepoint: Savepoint?) {
        throw SQLFeatureNotSupportedException("releaseSavepoint")
    }

    override fun rollback(savepoint: Savepoint?) {
        throw SQLFeatureNotSupportedException("rollback")
    }

    override fun setCatalog(catalog: String) {
        throw SQLFeatureNotSupportedException("setCatalog")
    }

    override fun setHoldability(holdability: Int) {
        throw SQLFeatureNotSupportedException("setHoldability")
    }

    override fun abort(executor: Executor?) {
        throw SQLFeatureNotSupportedException("abort")
    }

    override fun setNetworkTimeout(executor: Executor?, milliseconds: Int) {
        throw SQLFeatureNotSupportedException("setNetworkTimeout")
    }
}