package {{package}}.statement

import {{package}}.{{prefix}}Connection
import java.sql.*
import java.sql.Statement.SUCCESS_NO_INFO

class {{prefix}}Statement(conn: {{prefix}}Connection) : {{prefix}}AbsStatement(conn), Statement {

    private val batchOps = mutableListOf<String>()

    override fun execute(sql: String, autoGeneratedKeys: Int) = execute(sql)

    override fun execute(sql: String, columnIndexes: IntArray?) = execute(sql)

    override fun execute(sql: String, columnNames: Array<out String>?) = execute(sql)

    override fun clearBatch() {
        batchOps.clear()
    }

    override fun getResultSetType() = ResultSet.TYPE_FORWARD_ONLY

    override fun isCloseOnCompletion() = false

    override fun <T : Any> unwrap(iface: Class<T>): T? = null

    override fun getMaxRows() = 0

    override fun getConnection() = this.connection

    override fun getWarnings(): SQLWarning? = null

    override fun executeQuery(sql: String): ResultSet {
        this.execute(sql)
        return this.getResultSet()
    }

    override fun close() {
        isClosed = true
    }

    override fun isClosed() = this.isClosed

    override fun getMaxFieldSize() = 0

    override fun isWrapperFor(iface: Class<*>) = false

    override fun getUpdateCount() = -1

    override fun getFetchSize() = 0

    override fun executeBatch() = IntArray(batchOps.size).apply {
        this@{{prefix}}Statement.batchOps.forEachIndexed { index, sql ->
            try {
                this@{{prefix}}Statement.execute(sql)
                this[index] = SUCCESS_NO_INFO
            } catch (th: Throwable) {
                throw BatchUpdateException(th)
            }
        }
    }

    override fun getQueryTimeout() = 0

    override fun isPoolable() = false

    override fun addBatch(sql: String) {
        batchOps.add(sql)
    }

    override fun getGeneratedKeys(): ResultSet? = null

    override fun getResultSetConcurrency() = ResultSet.CONCUR_READ_ONLY

    override fun getResultSet() = this.resultSet

    override fun execute(sql: String) = executeForResultSet(sql)

    override fun executeUpdate(sql: String) = executeForResult(sql)

    override fun executeUpdate(sql: String, autoGeneratedKeys: Int) = executeUpdate(sql)

    override fun executeUpdate(sql: String, columnIndexes: IntArray?) = executeUpdate(sql)

    override fun executeUpdate(sql: String, columnNames: Array<out String>?) = executeUpdate(sql)

    override fun getFetchDirection() = 0

    override fun getResultSetHoldability() = ResultSet.CLOSE_CURSORS_AT_COMMIT

    override fun getMoreResults() = false

    override fun getMoreResults(current: Int) = false

    // ==== do nothing =========

    override fun clearWarnings() {
        // do nothing
    }

    override fun cancel() {
        // do nothing
    }

    override fun setMaxFieldSize(max: Int) {
        // do nothing
    }

    override fun setMaxRows(max: Int) {
        // do nothing
    }

    override fun setFetchDirection(direction: Int) {
        // do nothing
    }

    override fun setEscapeProcessing(enable: Boolean) {
        // do nothing
    }

    override fun setCursorName(name: String) {
        // do nothing
    }

    override fun setPoolable(poolable: Boolean) {
        // do nothing
    }

    override fun setFetchSize(rows: Int) {
        // do nothing
    }

    override fun setQueryTimeout(seconds: Int) {
        // do nothing
    }

    override fun closeOnCompletion() {
        // do nothing
    }


}